/*
```javascript
/**/

// Why do these docs look wierd? They are also the tests. Don't worry about it.

'use strict';

var test = require('tape')
var level = require('level')
var llibrarian = require('../index.js')
var pull = require('pull-stream')
var pl = require('pull-level')
var rimraf = require('rimraf')

/*
```
### Initialization
Initialize level-librarian by passing it a leveldb and an array of properties
that you would like to index on. You can also use keypaths, like `'content.id'`.
To create secondary indexes, use an array.

```javascript
/**/

var indexes = [
  'timestamp', // Property name
  'content.id', // Keypath
  [ 'content.id', 'timestamp' ] // Secondary index
]

function dbSetup (indexes) {
  rimraf.sync('./test.db')
  var db = level('./test.db')
  return db
}

/*
```
### .putWithIndex(key, value[, options][, callback])
- `key`: same as levelup
- `value`: same as levelup, except it will automatically stringify JSON for
you
- `options`: same as levelup, with the addition of 1 new option:
  - `indexes`: this is an array of indexes to create, it will override the
  indexes set at initialization

```javascript
/**/

test('.putWithIndex(key, value[, options][, callback])', function (t) {
  var value = {
    timestamp: '29304857',
    content: { name: 's1df34sa3df', flip: 'flop' }
  }

  var db = dbSetup(indexes);

  db.putWithIndex('w32fwfw33', value, function (err) {
    if (err) { throw err }
    pull(
      pl.read(db),
      pull.collect(function (err, array) {
        console.log(JSON.stringify(array,null,2))
        t.equal()
      })
    )
    t.end()
  })
})


rimraf.sync('./test.db')
var db = level('./test.db')


/*
```
## .write(db, indexes[, opts, done])
Returns a pull-stream sink that writes a stream of documents to the db, adding
index documents as well.
- `db`: A leveldb.
- `indexes`: An array of index keypaths.

#### Indexes array
level-librarian consumes index definitions as an object or array of keypaths,
or keypath arrays. Keypaths are resolved by safe-access, using the `value`
property of the document as a base. To create multi-level indexes, use an
array.
```javascript
/**/
var indexes = {
  // If you use a property that is not unique, only the latest document with
  // that property will be indexed.
  byScoreLatest: 'content.score', // Keypath

  // If this is not what you want, add a unique index. '..key' allows you to
  // index the key of the document.
  byScore: ['content.score', '..key'], // Secondary index

  byScoreByTime: ['content.score', 'timestamp', '..key'] // Tertiary index
}

var documents = [{
  key: 'w32fwfw33',
  value: {
    timestamp: '29304857',
    content: { name: 'richard', score: 4 }
  }
}, {
  key: '39djdjj31',
  value: {
    timestamp: '29304932',
    content: { name: 'mary', score: 5 }
  }
}, {
  key: 'dlnqoq003',
  value: {
    timestamp: '29304990',
    content: { name: 'jeff', score: 4 }
  }
}]

test('.write(db, indexes)', function (t) {
  pull(
    pull.values(documents),
    llibrarian.write(db, indexes, null, function () {
      console.log('yea' + arguments)
    })
  )
})
/*
```
## .read (db, query[, options])
Returns a pull-stream source of documents matching the query.
- `db`: A leveldb.
- `query`: A query in the `{ k: ..., v: ... }` format.
- `options`: same as the options passed into pull-level, except for the fact
that `gt`, `lt`, `gte`, `lte` will not work, as they are generated by
level-librarian.

#### Query format
level-librarian expects queries as objects with `k` and `v` properties.
- `k` is one of the index definitions that you supplied when writing.
- `v` is an array of value(s) to search for. If you supply an array with 2
values, level-librarian will find the documents in that range. If you leave an
index off, level-librarian will find documents with any value at that
position.
```javascript
/**/
var queryA = {
  k: indexes.byScoreByTime,
  v: [['s1df34sa3df'], ['29304857', '29304923']]
}

var queryB = {
  k: ['timestamp'],
  v: [['29304857', '29304923']]
}


// k.length < v.length === false

var queryC = {
  k: ['timestamp', '..key'],
  v: [['29304857', '29304923']]
}

var queryD = {
  k: ['timestamp', '..key'],
  v: ['29304857', '29304923']
}

test('.read (db, query[, options])', function (t) {
  pull(
    llibrarian.read(db, queryA),
    pull.collect(function (arr) {
      console.log(arr)
    })
  )
})
/*
```